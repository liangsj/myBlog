<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="liangSJ">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://liangsj.top">
    <!--SEO-->

    <meta name="keywords" content="webapp,docker-compose,redis,sentinel" />


    <meta name="description" content="前言在前一节中，已经实现了最简单的单点模式webapp 搭建。这种架构往往很难抗住高qps（每秒访问次数）的冲击。在业务发展，往往要进行改造。一套抗高访问量的系统往往是很复杂的，每一个组件都有其..." />



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />

    <!--Title-->


<title>服务的搭建及其演变 - 高可用分布式缓存系统构建 | liangSJ</title>


    <link rel="alternate" href="/atom.xml" title="liangSJ" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='liangSJ'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://liangsj.top">liangSJ</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/program/"><i class="fa "></i>编程</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>杂谈</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about/"><i class="fa "></i>关于我</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="服务的搭建及其演变 - 高可用分布式缓存系统构建">
            
	            服务的搭建及其演变 - 高可用分布式缓存系统构建
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/docker-compose/">docker-compose</a> <a class="tag-link" href="/tags/redis/">redis</a> <a class="tag-link" href="/tags/sentinel/">sentinel</a> <a class="tag-link" href="/tags/webapp/">webapp</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/06/28</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前一节中，已经实现了最简单的单点模式webapp 搭建。这种架构往往很难抗住高qps（每秒访问次数）的冲击。在业务发展，往往要进行改造。一套抗高访问量的系统往往是很复杂的，每一个组件都有其优化的点。在众多的环境中，数据库往往是最薄弱的一环.<br>对于数据库优化，目前有几种</p>
<ul>
<li>数据库上流进行缓存。将热数据存入内存数据库中，如常见的nosql数据库 redis、memcache；或者添加到webapp 的localcache中。这种方式优点是: 部署简单；执行简单。缺点是 入侵代码，增加代码复杂度；缓存数据存在不一致的风险；缓存命中率如果无法保证的话，也达不到保证下游安全的目的。</li>
<li>mysql 进行主从部署，一般来说主库只负责写操作，并将数据库内容同步更新到从库中。从库负责读操作。优点时：对代码入侵程度小；当某个库不可用时，我们可以进行切换。缺点是：在大规模的写操作时，可能会带来主从数据的延迟；主库压力大。</li>
<li>进行拆库拆表。 mysql 主从部署解决不了当数据急剧增加上，查询、插入过慢的问题。这时候一般我们会进行拆库拆表，这是一个痛苦的过程。其对业务代码入侵非常大。<br>上述几个方法，可能会同时存在。在这里介绍下，最常见的添加缓存的方案。并进行扩展，描述 redis 怎么进行主从部署以及自动进行主从切换（mysql 主从部署的大体也是这么一个流程，就不重复介绍了）。</li>
</ul>
<p>#相关工具<br>本节会用到新的三个伙伴</p>
<ul>
<li>redis ： 基于内存的 key-value 存储系统,能承受较高的qps，支持本地磁盘持久化备份。采用单线程的设计方案，逻辑相对简单。</li>
<li>docker-compose : docker 相关的手脚架工具，可以定义 、部署多个docker 容器。<br>（相信大家到我前一节又长又臭的docker run 命令已经有些无奈了。docker - compose 能帮助我们解决这个问题）</li>
<li>sentinel : 用于管理、监控 以及故障迁移 redis的工具</li>
</ul>
<h1 id="分布式环境构建"><a href="#分布式环境构建" class="headerlink" title="分布式环境构建"></a>分布式环境构建</h1><h2 id="缓存设计-基于docker单独redis搭建"><a href="#缓存设计-基于docker单独redis搭建" class="headerlink" title="缓存设计 -  基于docker单独redis搭建"></a>缓存设计 -  基于docker单独redis搭建</h2><p>这里引入 docker-compose 来帮助我们管理日益复杂的docker 容器<br><br><br>docker-compose 安装 <figure class="highlight plain"><figcaption><span>pip install -U docker-compose```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">安装好后，创建一个名为 docker-compose.yml文件 ```touch docker-compose.yml```,并往文件内添加以下内容</span><br><span class="line">```yml</span><br><span class="line">version: &apos;2.0&apos; # docker-compose.yml 的版本信息,这里写成2.X</span><br><span class="line">services:   # 要定义的服务信息，这里除了需要添加之前的webapp 和 mysql 的运行环境，还需要添加redis服务</span><br><span class="line">   webapp:</span><br><span class="line">        image: golang       # 镜像名称</span><br><span class="line">        container_name: webapp # 生成的容器名称</span><br><span class="line">        ports:</span><br><span class="line">            - 8080:80      # 宿主机器和容器的端口映射，这里是 宿主机器端口号:容器端口号</span><br><span class="line">        networks:</span><br><span class="line">            - front        # 此容器添加入的网络</span><br><span class="line">        volumes:</span><br><span class="line">            - ./go/webapp:/go/src/webapp   # 宿主机器目录和容器目录的映射， 这里是 宿主机器目录:容器内目录</span><br><span class="line">            - ./sh:/sh</span><br><span class="line">        command: sh /sh/start.sh       # 容器创建后要运行的命令</span><br></pre></td></tr></table></figure></p>
<p>上面这段配置相当于 上节的 <figure class="highlight docker"><figcaption><span>run -d -p  8080:80 -v $HOME/src/go/webapp:/go/src/webapp -v $HOME/src/sh:/sh --network front golang sh</span><a href="/sh/start.sh">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``</span><br></pre></td></tr></table></figure></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"> mysql:</span></span><br><span class="line"><span class="attr">      image:</span> mysql</span><br><span class="line"><span class="attr">      container_name:</span> mysql</span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">3306</span>:<span class="number">3306</span></span><br><span class="line"><span class="attr">      networks:</span></span><br><span class="line"><span class="bullet">          -</span> front</span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="attr">          "MYSQL_ROOT_PASSWORD":</span> <span class="string">"123456"</span> <span class="comment"># 容器内要设置的系统变量，这里是设置容器的mysql root密码</span></span><br><span class="line"><span class="attr"> redis_master:</span></span><br><span class="line"><span class="attr">      image:</span> redis</span><br><span class="line"><span class="attr">      container_name:</span> redis_master</span><br><span class="line"><span class="attr">      networks:</span></span><br><span class="line"><span class="bullet">          -</span> front</span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="number">7002</span>:<span class="number">6379</span></span><br><span class="line"><span class="attr">      restart:</span> always</span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span>     <span class="comment"># 定义网络信息</span></span><br><span class="line"><span class="attr">  front:</span> <span class="comment"># 新网络名称</span></span><br><span class="line"><span class="attr">      driver:</span> bridge <span class="comment"># 网络的模式,一般都选择bridge （docker中有多种网路模式，可以根据不同的使用场景进行使用，想深入了解，可以看docker官网介绍）</span></span><br></pre></td></tr></table></figure>
<p>webapp 中需要操作redis，这里依赖redigo这个开源的库，在启动之前把依赖下载的指令加入之前的start.sh 中,start.sh现在为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql &amp;&amp; go get -u github.com/garyburd/redigo/redis  &amp;&amp;  go run /go/src/webapp/main.go</span><br></pre></td></tr></table></figure>
<p>docker-compose.yml 完成后，在当前目录下执行 <figure class="highlight plain"><figcaption><span>up -d```,常见容器<br></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 ```docker container  ls -a</span><br></pre></td></tr></table></figure></p>
<img src="/images/2_compose_ret.png">
<p>看到我们的redis，mysql，webapp已经跑起来了</p>
<h2 id="代码改写"><a href="#代码改写" class="headerlink" title="代码改写"></a>代码改写</h2><p>基本的开发环境已经搭建完毕，现在改写我们之前的webapp 代码<br><br>这里先添加 三个关于缓存操作的代码<br><br><br>添加缓存<br><br><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将点赞数放入redis_master缓存中</span></span><br><span class="line"><span class="keyword">func</span> setToCache(resourceID <span class="keyword">int64</span>, praiseCount <span class="keyword">int64</span>) error &#123;</span><br><span class="line">        conn, err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"redis_master:6379"</span>) <span class="comment">//连接redis, host:port形式，host是上面定义的容器名称，port 是redis容器的redis服务端口号</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line">        <span class="comment">//const praise_count_cache_key_fmt string = "resource_%d_prasie_cache"</span></span><br><span class="line">        key := fmt.Sprintf(praise_count_cache_key_fmt, resourceID) </span><br><span class="line">        _, err = conn.Do(<span class="string">"SET"</span>, key, praiseCount) <span class="comment">//将结果放入redis中</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br>清除缓存<br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//清除缓存数据</span><br><span class="line">func CleanCache(resourceID int64) error &#123;</span><br><span class="line">        conn, err := redis.Dial(&quot;tcp&quot;, &quot;redis_master:6379&quot;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return err</span><br><span class="line">        &#125;</span><br><span class="line">        defer conn.Close()</span><br><span class="line">        key := fmt.Sprintf(praise_count_cache_key_fmt, resourceID)</span><br><span class="line">        _, err = conn.Do(&quot;DEL&quot;, key)</span><br><span class="line">        return err</span><br><span class="line">&#125;</span><br><span class="line">```go</span><br><span class="line">&lt;br&gt;</span><br><span class="line">从缓存中获取数据</span><br><span class="line">&lt;br&gt;</span><br><span class="line">``` go</span><br><span class="line">//从redis_master中获取点赞数</span><br><span class="line">func getFromCache(resourceID int64) (int64, error) &#123;</span><br><span class="line">        conn, err := redis.Dial(&quot;tcp&quot;, &quot;redis_master:6379&quot;)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return 0, err</span><br><span class="line">        &#125;</span><br><span class="line">        defer conn.Close()</span><br><span class="line">        key := fmt.Sprintf(praise_count_cache_key_fmt, resourceID)</span><br><span class="line">        praiseCount, err := redis.Int64(conn.Do(&quot;GET&quot;, key))</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return 0, err</span><br><span class="line">        &#125;</span><br><span class="line">        return praiseCount, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来修改主流程里面的代码<br><br><br>删除缓存操作放在写操作内，保证缓存一致<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">func</span> setPrasieCount(w http.ResponseWriter, req *http.Request) &#123; </span><br><span class="line">       ..... <span class="comment">//省略代码，如需要看上一节，在git中下载</span></span><br><span class="line">        _, err = db.Query(sql)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                returnErrMsg(w, <span class="number">-1</span>, fmt.Sprintf(<span class="string">"%v"</span>, err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        CleanCache(resourceID) <span class="comment">//在添加点赞数是删除缓存</span></span><br><span class="line">        retBytes, _ := json.Marshal(Response&#123;Errno: <span class="number">0</span>&#125;)</span><br><span class="line">        io.WriteString(w, <span class="keyword">string</span>(retBytes))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>读取缓存<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> getPrasieCount(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">        ... <span class="comment">//省略参数获取部分</span></span><br><span class="line">        praiseCount, err := getFromCache(resourceID)  <span class="comment">// 从缓存读取点赞数</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != redis.ErrNil &#123;</span><br><span class="line">                returnErrMsg(w, <span class="number">-1</span>, fmt.Sprintf(<span class="string">"%v"</span>, err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != redis.ErrNil &#123; <span class="comment">//当缓存内有数据时直接返回</span></span><br><span class="line"></span><br><span class="line">                res := &amp;Response&#123;Errno: <span class="number">0</span>, Data: &amp;Item&#123;ResourceID: resourceID, Count: praiseCount&#125;&#125;</span><br><span class="line">                retBytes, _ := json.Marshal(res)</span><br><span class="line">                setToCache(resourceID, praiseCount)</span><br><span class="line">                io.WriteString(w, <span class="keyword">string</span>(retBytes))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">//省略从数据库读取数据部分</span></span><br><span class="line">        </span><br><span class="line">        setToCache(resourceID, count) <span class="comment">//缓存内没有数据，将从数据库里面读到的数据放入缓存中，以便下次使用</span></span><br><span class="line">        retBytes, _ := json.Marshal(res)</span><br><span class="line">        io.WriteString(w, <span class="keyword">string</span>(retBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上述代码中，可以看到，在读取点赞数时，先读缓存，如果缓存有数据我们直接当做结果进行返回。如果结果中没有数据，在进行数据库查询，并将查询结果放回redis-cache中。当有足够的高的缓存命中率时，能很好减少到下游db的流量，从而达到保护db的目的<br><br>在写点赞数时，会把redis cache的数据进行删除，从而保证下次直读db，保证数据的一致性。<strong><em>存在缓存设计的风险点，当缓存删除失败时，会造成缓存数据和db数据不一致，对于要求数据强一致的业务不能这么进行设计</em></strong></p>
<h2 id="主从结构的分流设计-基于docker带有主从结构的redis-搭建"><a href="#主从结构的分流设计-基于docker带有主从结构的redis-搭建" class="headerlink" title="主从结构的分流设计 - 基于docker带有主从结构的redis 搭建"></a>主从结构的分流设计 - 基于docker带有主从结构的redis 搭建</h2><p>至此，保护db的目的已经达到了。假设缓存流量持续上涨，缓存命中率也较高的情况下。redis-cache会成为新的瓶颈，除了在redis -cache 上在加一层在服务器上的local-cache外。我们还有第二个解决方案 ，进行主从结构的部署,（这里提供redis的解决方案，db也可以参考这种方案）。 redis 本身就支持主从结构的部署，只需要简单的命令 <figure class="highlight plain"><figcaption><span>--slaveof <$redis_master_host> <$redis_master_port>``` 即可<br></$redis_master_port></$redis_master_host></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面解决往docker-compose.yml添加新服务</span><br></pre></td></tr></table></figure></p>
<p> redis_slave_1:<br>        image: redis<br>        ports:</p>
<pre><code>    - 7003:6379
restart: always
container_name: redis_slave_1
command: redis-server --slaveof redis_master 6379 #启动一个redis服务，并设置成为redis_master的从库
networks:
    - front
image: redis
restart: always
</code></pre><p>   redis_slave_2:<br>        image: redis<br>        ports:</p>
<pre><code>    - 7004:6379
restart: always
container_name: redis_slave_2
networks:
    - front
image: redis
restart: always
command: redis-server --slaveof redis_master 6379
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">修改完成后，执行 ```docker-compose up -d``` 镜像重新部署</span><br><span class="line"></span><br><span class="line">&#123;%img /images/2_compose_ret2.png%&#125;</span><br><span class="line">结果显示，我们两个redis 的从库已经部署好了</span><br><span class="line">### 代码改写</span><br><span class="line">下面进行读写入口的改写</span><br><span class="line">```go</span><br><span class="line"></span><br><span class="line">//从redis_master中获取点赞数</span><br><span class="line">func getFromCache(resourceID int64) (int64, error) &#123;</span><br><span class="line">        conn, err := redis.Dial(&quot;tcp&quot;, &quot;redis_slave_1:6379&quot;) //更改读逻辑的redis入口</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                return 0, err</span><br><span class="line">        &#125;</span><br><span class="line">        ....//省略其他逻辑</span><br><span class="line">       return praiseCount, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，写缓存流量在redis_master 主库上，读流量在从库上（从库如果有写操作会进行保存），大大减少redis master主库上的流量，从而达到分流的目的</p>
<h2 id="自动主从切换-基于docker的sentine-环境搭建"><a href="#自动主从切换-基于docker的sentine-环境搭建" class="headerlink" title="自动主从切换 - 基于docker的sentine 环境搭建"></a>自动主从切换 - 基于docker的sentine 环境搭建</h2><p>通过以上两个设计，系统稳定性已经上升了一个档次。但，我们观察到，主库现在又面临着单点的问题。如果主库出现可用性问题，结果往往是灾难的。我们需要套机制来进行监控主库和稳定性和当出现问题时，能进行主从切换,我们依旧以redis为例<br>sentinel作为最常用的redis 监控、主从切换工具而被广泛应用。首先，先进行sentinel配置的编写,保存为 sentinel.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379 # sentinel 的服务端口</span><br><span class="line"></span><br><span class="line">dir /tmp  # 工作文件目录</span><br><span class="line"></span><br><span class="line">sentinel monitor master redis_master 6379 1 # 对redis主库进行监听 后面三个参数的意思分别是 ： 主库的host，主库的端口，当 1 个sentinel 检查出现错误后，自动进行主从切换</span><br><span class="line">sentinel down-after-milliseconds master 30000 # 心跳检查，当主库在30000 ms内没有应答，则认为其已经不可用，进行容灾操作</span><br></pre></td></tr></table></figure></p>
<h3 id="代码改写-1"><a href="#代码改写-1" class="headerlink" title="代码改写"></a>代码改写</h3><h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><h2 id="生产环境中的注意点"><a href="#生产环境中的注意点" class="headerlink" title="生产环境中的注意点"></a>生产环境中的注意点</h2>
    </div>
    
    <div class="post-footer">
        <div>
            
                TIPS：如果喜欢我的文章欢迎给我留言
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/06/28/server_1/" class="pre-post btn btn-default" title='服务的搭建及其演变 -简单的单点服务搭建'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">服务的搭建及其演变 -简单的单点服务搭建</span>
        </a>
    
    
        <a href="/2016/05/31/tree/" class="next-post btn btn-default" title='tree'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">tree</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式环境构建"><span class="toc-text">分布式环境构建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存设计-基于docker单独redis搭建"><span class="toc-text">缓存设计 -  基于docker单独redis搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码改写"><span class="toc-text">代码改写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主从结构的分流设计-基于docker带有主从结构的redis-搭建"><span class="toc-text">主从结构的分流设计 - 基于docker带有主从结构的redis 搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动主从切换-基于docker的sentine-环境搭建"><span class="toc-text">自动主从切换 - 基于docker的sentine 环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码改写-1"><span class="toc-text">代码改写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果验证"><span class="toc-text">结果验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生产环境中的注意点"><span class="toc-text">生产环境中的注意点</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>